
-------------------------------------------------------------------
- Arquivo: src\temporal\activities\payment.activities.ts
-------------------------------------------------------------------
import axios from 'axios';
import { DataSource } from 'typeorm';
import { PaymentOrmEntity } from '../../infrastructure/persistence/payment/payment.orm-entity';
import { PaymentStatus } from '../../domain/payment/payment.enums';

const api = axios.create({
  baseURL: 'https://api.mercadopago.com',
  headers: { Authorization: `Bearer ${process.env.MP_ACCESS_TOKEN}` }
});

export async function createPreference(payment: any) {
  const body = {
    items: [
      {
        title: payment.description,
        quantity: 1,
        currency_id: 'BRL',
        unit_price: Number(payment.amount)
      }
    ],
    external_reference: payment.id
  };

  const { data } = await api.post('/checkout/preferences', body);

  // üî• SALVA A URL E O ID DA PREFERENCE NO BANCO
  const ds = new DataSource({
    type: 'postgres',
    host: process.env.DB_HOST,
    port: parseInt(process.env.DB_PORT ?? '5432'),
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
    database: process.env.DB_NAME,
    entities: [PaymentOrmEntity],
  });

  await ds.initialize();

  await ds
    .getRepository(PaymentOrmEntity)
    .update(payment.id, {
      mercadoPagoPreferenceId: data.id,
      paymentUrl: data.init_point   // üëà SALVA A URL AQUI
    });

  await ds.destroy();

  return data;
}

export async function getPaymentStatus(internalId: string) {
  const { data } = await api.get(`/v1/payments/search`, {
    params: { external_reference: internalId }
  });

  if (!data.results || data.results.length === 0) {
    return null;
  }

  return data.results[0].status;
}

export async function updatePaymentStatus(internalId: string, status: string) {
  const ds = new DataSource({
    type: 'postgres',
    host: process.env.DB_HOST,
    port: parseInt(process.env.DB_PORT ?? '5432'),
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
    database: process.env.DB_NAME,
    entities: [PaymentOrmEntity],
  });

  await ds.initialize();

  await ds
    .getRepository(PaymentOrmEntity)
    .update(internalId, { status: status as PaymentStatus });

  await ds.destroy();
}



-------------------------------------------------------------------
- Arquivo: src\temporal\worker.ts
-------------------------------------------------------------------
import { Worker } from '@temporalio/worker';
import * as dotenv from 'dotenv';
dotenv.config();

async function run() {
  const worker = await Worker.create({
    taskQueue: 'PAYMENT_QUEUE',

    // Pasta com index.ts exportando workflows
    workflowsPath: require.resolve('./workflows'),

    // Activities carregadas como objeto
    activities: require('./activities/payment.activities'),
  });

  await worker.run();
}

run().catch(console.error);



-------------------------------------------------------------------
- Arquivo: src\temporal\workflows\index.ts
-------------------------------------------------------------------
export * from './payment.workflow';


-------------------------------------------------------------------
- Arquivo: src\temporal\workflows\payment.workflow.ts
-------------------------------------------------------------------
import {
  proxyActivities,
  sleep,
  defineSignal,
  setHandler,
  log
} from '@temporalio/workflow';

const { createPreference, getPaymentStatus, updatePaymentStatus } = proxyActivities({
  startToCloseTimeout: "1 minute",
});

// üî• Signal recebido diretamente do Webhook
export const paymentStatusSignal = defineSignal<[string]>("paymentStatusSignal");

export async function PaymentWorkflow(input: {
  paymentId: string;
  description: string;
  amount: number;
}) {

  let finalStatus: string | null = null;

  // Handler que recebe o sinal enviado pelo webhook
  setHandler(paymentStatusSignal, (status) => {
    log.info(`üì© Signal recebido do webhook: ${status}`);
    finalStatus = status;
  });

  // Marca como pendente no in√≠cio
  await updatePaymentStatus(input.paymentId, "PENDING");

  // Cria a preference no Mercado Pago
  const pref = await createPreference({
    id: input.paymentId,
    description: input.description,
    amount: input.amount,
  });

  log.info("üßæ Preference criada no Mercado Pago", {
    paymentId: input.paymentId,
    preferenceId: pref.id,
  });

  // üîÅ Loop de execu√ß√£o cont√≠nua do workflow
  while (true) {

    // Caso o signal tenha sido recebido ‚Üí encerra imediatamente
    if (finalStatus) {
      log.info(`üéØ Workflow finalizado via signal: ${finalStatus}`);
      await updatePaymentStatus(input.paymentId, finalStatus);
      return;
    }

    // Espera antes de consultar novamente
    await sleep(10_000);

    // Polling como fallback (para seguran√ßa)
    const status = await getPaymentStatus(input.paymentId);

    if (status === "approved") {
      log.info("üíö Pagamento aprovado via polling");
      await updatePaymentStatus(input.paymentId, "PAID");
      return;
    }

    if (status === "rejected" || status === "cancelled") {
      log.info("üíî Pagamento falhou via polling");
      await updatePaymentStatus(input.paymentId, "FAIL");
      return;
    }
  }
}


