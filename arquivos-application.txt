
-------------------------------------------------------------------
- Arquivo: src\application\payment\controllers\mercadopago-webhook.controller.ts
-------------------------------------------------------------------
import { Body, Controller, Post, Query } from '@nestjs/common';
import { PaymentService } from '../services/payment.service';

@Controller('api/payment/mercadopago')
export class MercadoPagoWebhookController {
  constructor(private readonly paymentService: PaymentService) {}

  @Post('webhook')
  async webhook(@Body() body: any, @Query() query: any) {
    await this.paymentService.handleMercadoPagoWebhook(query, body);
    return { received: true };
  }
}



-------------------------------------------------------------------
- Arquivo: src\application\payment\controllers\payment.controller.ts
-------------------------------------------------------------------
import { Body, Controller, Get, Param, Post, Put, Query } from '@nestjs/common';
import { PaymentService } from '../services/payment.service';
import { CreatePaymentDto } from '../dto/create-payment.dto';
import { UpdatePaymentDto } from '../dto/update-payment.dto';
import { FilterPaymentDto } from '../dto/filter-payment.dto';

@Controller('api/payment')
export class PaymentController {
  constructor(private readonly paymentService: PaymentService) {}

  @Post()
  create(@Body() dto: CreatePaymentDto) {
    return this.paymentService.createPayment(dto);
  }

  @Put(':id')
  update(@Param('id') id: string, @Body() dto: UpdatePaymentDto) {
    return this.paymentService.updatePayment(id, dto);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.paymentService.getPayment(id);
  }

  @Get()
  findAll(@Query() filter: FilterPaymentDto) {
    return this.paymentService.listPayments(filter);
  }
}



-------------------------------------------------------------------
- Arquivo: src\application\payment\dto\create-payment.dto.ts
-------------------------------------------------------------------
import { IsEnum, IsNotEmpty, IsNumber, IsPositive, IsString, Length, Matches } from 'class-validator';
import { PaymentMethod } from '../../../domain/payment/payment.enums';

export class CreatePaymentDto {
  @IsString()
  @Length(11,11)
  @Matches(/^\d+$/)
  cpf: string;

  @IsString()
  @IsNotEmpty()
  description: string;

  @IsNumber()
  @IsPositive()
  amount: number;

  @IsEnum(PaymentMethod)
  paymentMethod: PaymentMethod;
}



-------------------------------------------------------------------
- Arquivo: src\application\payment\dto\filter-payment.dto.ts
-------------------------------------------------------------------
import { IsEnum, IsOptional, IsString, Length, Matches } from 'class-validator';
import { PaymentMethod } from '../../../domain/payment/payment.enums';

export class FilterPaymentDto {
  @IsOptional()
  @IsString()
  @Length(11,11)
  @Matches(/^\d+$/)
  cpf?: string;

  @IsOptional()
  @IsEnum(PaymentMethod)
  paymentMethod?: PaymentMethod;
}



-------------------------------------------------------------------
- Arquivo: src\application\payment\dto\update-payment.dto.ts
-------------------------------------------------------------------
import { IsEnum } from 'class-validator';
import { PaymentStatus } from '../../../domain/payment/payment.enums';

export class UpdatePaymentDto {
  @IsEnum(PaymentStatus)
  status: PaymentStatus;
}



-------------------------------------------------------------------
- Arquivo: src\application\payment\payment.module.ts
-------------------------------------------------------------------
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PaymentOrmEntity } from '../../infrastructure/persistence/payment/payment.orm-entity';
import { PaymentTypeOrmRepository } from '../../infrastructure/persistence/payment/payment.typeorm-repository';
import { PaymentService } from './services/payment.service';
import { MercadoPagoService } from './services/mercadopago.service';
import { PaymentController } from './controllers/payment.controller';
import { MercadoPagoWebhookController } from './controllers/mercadopago-webhook.controller';

@Module({
  imports: [TypeOrmModule.forFeature([PaymentOrmEntity])],
  controllers: [PaymentController, MercadoPagoWebhookController],
  providers: [PaymentTypeOrmRepository, PaymentService, MercadoPagoService]
})
export class PaymentModule {}



-------------------------------------------------------------------
- Arquivo: src\application\payment\services\mercadopago.service.ts
-------------------------------------------------------------------
import { Injectable } from '@nestjs/common';
import axios from 'axios';

@Injectable()
export class MercadoPagoService {
  private readonly api = axios.create({
    baseURL: 'https://api.mercadopago.com',
    headers: {
      Authorization: `Bearer ${process.env.MP_ACCESS_TOKEN}`
    }
  });

  async createPreference(payment: any){
    const body = {
      items: [
        { title: payment.description, quantity: 1, currency_id: 'BRL', unit_price: Number(payment.amount) }
      ],
      external_reference: payment.id,
      notification_url: 'https://ursine-jadon-alterably.ngrok-free.dev/api/payment/mercadopago/webhook'
    };

    const { data } = await this.api.post('/checkout/preferences', body);
    return data;
  }

  async getPayment(id: string){
    const { data } = await this.api.get(`/v1/payments/${id}`);
    return data;
  }
}



-------------------------------------------------------------------
- Arquivo: src\application\payment\services\payment.service.ts
-------------------------------------------------------------------
import { Injectable, NotFoundException } from '@nestjs/common';
import { PaymentTypeOrmRepository } from '../../../infrastructure/persistence/payment/payment.typeorm-repository';
import { CreatePaymentDto } from '../dto/create-payment.dto';
import { UpdatePaymentDto } from '../dto/update-payment.dto';
import { FilterPaymentDto } from '../dto/filter-payment.dto';
import { PaymentStatus, PaymentMethod } from '../../../domain/payment/payment.enums';
import { MercadoPagoService } from './mercadopago.service';
import { Client, Connection } from '@temporalio/client';
import { paymentStatusSignal } from '../../../temporal/workflows/payment.workflow';

@Injectable()
export class PaymentService {
  constructor(
    private readonly repo: PaymentTypeOrmRepository,
    private readonly mp: MercadoPagoService
  ){}

async createPayment(dto: CreatePaymentDto) {
  const payment = await this.repo.create({
    ...dto,
    status: PaymentStatus.PENDING
  } as any);

  if(dto.paymentMethod === PaymentMethod.CREDIT_CARD) {

    const connection = await Connection.connect();
    const client = new Client({ connection });

    const handle = await client.workflow.start('PaymentWorkflow', {
      taskQueue: 'PAYMENT_QUEUE',
      workflowId: `payment-${payment.id}`,
      args: [{
        paymentId: payment.id,
        description: dto.description,
        amount: dto.amount
      }]
    });

    // ðŸ”¥ Consulta imediata via QUERY (sem sleep)
    let url = '';
    while(!url) {
      url = await handle.query('getPreferenceUrl');
      if (!url) await new Promise(r => setTimeout(r, 100));
    }

    return {
      id: payment.id,
      workflow: handle.workflowId,
      paymentUrl: url,
      message: "Preference criada"
    };
  }

  return payment;
}

  async updatePayment(id: string, dto: UpdatePaymentDto){
    return await this.repo.updateStatus(id, dto.status);
  }

  async getPayment(id: string){
    const p = await this.repo.findById(id);
    if(!p) throw new NotFoundException("Payment not found");
    return p;
  }

  async listPayments(filter: FilterPaymentDto){
    return await this.repo.findAll(filter);
  }

  async handleMercadoPagoWebhook(query: any, body: any) {
    const paymentId = query['data.id'] || body.data?.id;
    if (!paymentId) return;

    const mpPayment = await this.mp.getPayment(paymentId);
    const internalId = mpPayment.external_reference;
    if (!internalId) return;

    const status = mpPayment.status === 'approved'
        ? PaymentStatus.PAID
        : PaymentStatus.FAIL;

    // ðŸ”¥ Atualiza o banco imediatamente
    await this.repo.updateStatus(internalId, status);

    // ðŸ”¥ Envia o SIGNAL para o Workflow encerrar AGORA
    const connection = await Connection.connect();
    const client = new Client({ connection });

    const handle = client.workflow.getHandle(`payment-${internalId}`);

    await handle.signal("paymentStatusSignal", status);
  }
}


